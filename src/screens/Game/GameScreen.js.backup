// File: src/screens/Game/GameScreen.js

import React, { useState, useEffect, useRef, useCallback } from 'react'
import {
  View,
  Text,
  StyleSheet,
  Alert,
  Button,
  AppState,
  Dimensions,
  TouchableOpacity
} from 'react-native'
import AdBanner from '../../components/AdBanner';
import { useFocusEffect } from '@react-navigation/native'
import { Ionicons } from '@expo/vector-icons'
import * as Haptics from 'expo-haptics'

import Board from '../../components/sudoku/SudokuBoard'
import NumberPad from '../../components/sudoku/NumberPad'
import HintButton from '../../components/sudoku/HintButton'
import UndoRedoControls from '../../components/sudoku/UndoRedoControls'

import { generateSudokuPuzzle } from '../../utils/SudokuGenerator'
import { findConflicts, isBoardSolved } from '../../utils/SudokuValidator'
import { useGameSettings } from '../../contexts/GameSettingsContext'
import { useTheme } from '../../contexts/ThemeContext'
import { saveGame, loadGame } from '../../services/GameStorageService'
import 'react-native-get-random-values'
import { v4 as uuidv4 } from 'uuid'

const { width }      = Dimensions.get('window')
const boardSize      = width * 0.9
const numberPadWidth = width * 0.85

export default function GameScreen({ route, navigation }) {
  const { selectedDifficulty, dailyChallengeId, setDailyChallengeId } = useGameSettings()
  const { colors }                = useTheme()
  const isDaily                   = route.params?.isDailyChallenge === true

  // Game state
  const [gameId, setGameId]             = useState(null)
  const [initialBoard, setInitialBoard] = useState([])
  const [currentBoard, setCurrentBoard] = useState([])
  const [solutionBoard, setSolutionBoard] = useState([])
  const [selectedCell, setSelectedCell] = useState(null)
  const [conflictingCells, setConflictingCells] = useState(new Set())
  const [hintsRemaining, setHintsRemaining] = useState(3)
  const [timeElapsed, setTimeElapsed] = useState(0)
  const [isGameActive, setIsGameActive] = useState(false)
  const [history, setHistory] = useState([])
  const [historyPointer, setHistoryPointer] = useState(-1)
  const [filledCount, setFilledCount] = useState(0)

  const appState = useRef(AppState.currentState)
  const timerRef = useRef(null)

  // Format mm:ss
  const formatTime = secs => {
    const m = Math.floor(secs / 60).toString().padStart(2, '0')
    const s = (secs % 60).toString().padStart(2, '0')
    return `${m}:${s}`
  }

  // Initialize or resume puzzle
  const initializeGame = useCallback(async () => {
    // 1) Resume daily if flagged
    if (isDaily && dailyChallengeId) {
      const loaded = await loadGame(dailyChallengeId)
      if (loaded) {
        setGameId(loaded.id)
        setInitialBoard(loaded.initialBoard)
        setCurrentBoard(loaded.currentBoard)
        setSolutionBoard(loaded.solutionBoard)
        setHintsRemaining(loaded.hintsRemaining ?? 3)
        setTimeElapsed(loaded.timeElapsed ?? 0)
        setHistory(loaded.history || [])
        setHistoryPointer(loaded.historyPointer ?? -1)
        setIsGameActive(true)
        return
      }
      // otherwise fall through and generate fresh daily
    }

    // 2) New daily or brand-new
    const newId = isDaily
      ? (dailyChallengeId || uuidv4())
      : uuidv4()

    const { puzzle, solution } = generateSudokuPuzzle(
      selectedDifficulty.cellsToRemove
    )

    if (isDaily) {
      setDailyChallengeId(newId)
    }

    setGameId(newId)
    setInitialBoard(puzzle)
    setCurrentBoard(puzzle.map(r => [...r]))
    setSolutionBoard(solution)
    setHintsRemaining(3)
    setTimeElapsed(0)
    setHistory([puzzle.map(r => [...r])])
    setHistoryPointer(0)
    setIsGameActive(true)
  }, [
    isDaily,
    dailyChallengeId,
    selectedDifficulty,
    setDailyChallengeId
  ])

  // Filled cells count
  useEffect(() => {
    let cnt = 0
    currentBoard.forEach(r => r.forEach(v => v && cnt++))
    setFilledCount(cnt)
  }, [currentBoard])

  // On screen focus, init or resume
  useFocusEffect(useCallback(() => {
    initializeGame()
    return () => {
      setIsGameActive(false)
      clearInterval(timerRef.current)
    }
  }, [initializeGame]))

  // Ticking timer
  useEffect(() => {
    if (isGameActive) {
      timerRef.current = setInterval(() => setTimeElapsed(t => t + 1), 1000)
    } else {
      clearInterval(timerRef.current)
    }
    return () => clearInterval(timerRef.current)
  }, [isGameActive])

  // Auto‐save on any change
  useEffect(() => {
    if (gameId && currentBoard.length === 9) {
      saveGame({
        id: gameId,
        initialBoard,
        currentBoard,
        solutionBoard,
        selectedDifficulty,
        hintsRemaining,
        timeElapsed,
        history,
        historyPointer
      })
    }
  }, [
    gameId,
    initialBoard,
    currentBoard,
    solutionBoard,
    selectedDifficulty,
    hintsRemaining,
    timeElapsed,
    history,
    historyPointer
  ])

  // Pause/resume on background
  useEffect(() => {
    const sub = AppState.addEventListener('change', next => {
      setIsGameActive(next === 'active')
      appState.current = next
    })
    return () => sub.remove()
  }, [])

  // Conflict & win detection
  useEffect(() => {
    if (currentBoard.length === 9) {
      const conf = findConflicts(currentBoard)
      setConflictingCells(conf)
      if (conf.size > 0) {
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium)
      }
      if (conf.size === 0 && isBoardSolved(currentBoard)) {
        setIsGameActive(false)
        Alert.alert(
          'Congratulations!',
          `Solved in ${formatTime(timeElapsed)}!`,
          [
            { text: 'New Game', onPress: initializeGame },
            { text: 'OK' }
          ]
        )
      }
    }
  }, [currentBoard, timeElapsed, initializeGame])

  // Board/history updater
  const updateBoard = newBoard => {
    const slice = history.slice(0, historyPointer + 1)
    slice.push(newBoard)
    setHistory(slice)
    setHistoryPointer(slice.length - 1)
    setCurrentBoard(newBoard)
  }

  // Number pad handlers
  const onNumber = num => {
    if (!selectedCell) return
    const { row, col } = selectedCell
    if (initialBoard[row][col] === 0) {
      const nb = currentBoard.map(r => [...r])
      nb[row][col] = num
      updateBoard(nb)
    }
  }
  const onClear = () => {
    if (!selectedCell) return
    const { row, col } = selectedCell
    if (initialBoard[row][col] === 0) {
      const nb = currentBoard.map(r => [...r])
      nb[row][col] = 0
      updateBoard(nb)
    }
  }

  // Solve (disabled on daily)
  const onSolve = () => {
    if (isDaily) return
    Alert.alert(
      'Solve Puzzle?',
      'This will fill in all answers.',
      [
        { text: 'Cancel', style: 'cancel', onPress: () => setIsGameActive(true) },
        {
          text: 'Solve',
          onPress: () => {
            setCurrentBoard(solutionBoard.map(r => [...r]))
            setSelectedCell(null)
            setHistory([solutionBoard.map(r => [...r])])
            setHistoryPointer(0)
          }
        }
      ]
    )
  }

  // Hint / undo / redo / select
  const onHint   = () => {
    if (hintsRemaining <= 0) {
      return Alert.alert('No Hints Left','Visit the store to get more!')
    }
    let empty = null
    for (let r=0; r<9 && !empty; r++){
      for (let c=0; c<9; c++){
        if (currentBoard[r][c] === 0){
          empty = { row: r, col: c }
          break
        }
      }
    }
    if (empty){
      const { row, col } = empty
      const val = solutionBoard[row][col]
      const nb  = currentBoard.map(r => [...r])
      nb[row][col] = val
      updateBoard(nb)
      setHintsRemaining(h => h - 1)
      setSelectedCell(null)
      Alert.alert('Hint Used',`Cell (${row+1},${col+1}) = ${val}`)
    } else {
      Alert.alert('Done','No empty cells remain.')
    }
  }
  const onUndo   = () => {
    if (historyPointer > 0) {
      const p = historyPointer - 1
      setHistoryPointer(p)
      setCurrentBoard(history[p])
    }
  }
  const onRedo   = () => {
    if (historyPointer < history.length - 1) {
      const p = historyPointer + 1
      setHistoryPointer(p)
      setCurrentBoard(history[p])
    }
  }
  const onSelect = (r,c) => {
    if (initialBoard[r][c] === 0) setSelectedCell({ row: r, col: c })
    else setSelectedCell(null)
  }
  const onBack   = () => navigation.navigate('MainTabs',{ screen: 'Home' })

  // Loading placeholder
  if (currentBoard.length < 9) {
    return (
      <View style={[styles.container, { backgroundColor: colors.background }]}>
        <Text style={[styles.loadingText, { color: colors.text }]}>Loading…</Text>
      </View>
    )
  }

  // -- RENDER --
  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      {/* Header */}
      <View style={styles.headerContainer}>
        <TouchableOpacity onPress={onBack} style={styles.backButton}>
          <Ionicons name="chevron-back" size={24} color={colors.accent}/>
          <Text style={[styles.backButtonText,{ color: colors.accent }]}>Home</Text>
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: colors.text }]}>Sudoku</Text>
      </View>

      {/* Difficulty Label */}
      <Text style={[styles.title, { color: colors.text }]}>{selectedDifficulty.name}</Text>

      {/* Timer & Progress */}
      <View style={styles.statsContainer}>
        <Text style={[styles.timerText, { color: colors.text }]}>{formatTime(timeElapsed)}</Text>
        <Text style={[styles.progressText, { color: colors.textSecondary }]}>{filledCount} / 81</Text>
      </View>

      {/* Board */}
      <Board
        boardData={currentBoard}
        initialBoard={initialBoard}
        selectedCell={selectedCell}
        onCellSelect={onSelect}
        conflictingCells={conflictingCells}
        boardSize={boardSize}
      />

      {/* Number Pad */}
      <NumberPad
        onNumberPress={onNumber}
        onClearPress={onClear}
        numberPadWidth={numberPadWidth}
      />

      {/* Bottom Buttons */}
      <View style={styles.bottomButtonsContainer}>
        <View style={styles.buttonWrapper}>
          <Button title="Solve" onPress={onSolve} color={colors.accent} disabled={isDaily}/>
        </View>
        <View style={styles.buttonWrapper}>
          <HintButton onPress={onHint} disabled={hintsRemaining<=0} color={colors.accent}/>
        </View>
      </View>

      {/* Undo/Redo */}
      <UndoRedoControls
        onUndo={onUndo}
        onRedo={onRedo}
        canUndo={historyPointer>0}
        canRedo={historyPointer<history.length-1}
        color={colors.accent}
      />
            {/* Ad Banner */}
      <AdBanner adUnitID={colors.adUnitID /* replace with your real unit in production */} />

    </View>
  )
}

const styles = StyleSheet.create({
  container:            { flex:1, alignItems:'center', paddingHorizontal:5, paddingTop:70, paddingBottom:30 },
  headerContainer:      { flexDirection:'row', alignItems:'center', width:'100%', paddingHorizontal:10, marginBottom:10 },
  backButton:           { flexDirection:'row', alignItems:'center', padding:5 },
  backButtonText:       { fontSize:16, marginLeft:5 },
  headerTitle:          { flex:1, textAlign:'center', fontSize:18, fontWeight:'bold', marginRight:60 },
  loadingText:          { fontSize:18, marginTop:50 },
  title:                { fontSize:18, fontWeight:'bold', marginBottom:5 },
  statsContainer:       { flexDirection:'row', justifyContent:'space-between', width:'90%', marginBottom:15 },
  timerText:            { fontSize:18, fontWeight:'600' },
  progressText:         { fontSize:15 },
  bottomButtonsContainer:{ flexDirection:'row', justifyContent:'space-between', marginTop:15, marginBottom:15, width:'95%' },
  buttonWrapper:        { flex:1, marginHorizontal:5 }
})
